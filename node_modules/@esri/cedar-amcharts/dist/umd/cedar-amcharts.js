/**
* @esri/cedar-amcharts - v1.0.0 - Wed May 01 2019 11:12:08 GMT-0700 (PDT)
* Copyright (c) 2019 Environmental Systems Research Institute, Inc.
* ISC
*/
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.cedarAmCharts = {})));
}(this, (function (exports) { 'use strict';

    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
        return Array.isArray(val) ? [] : {}
    }

    function cloneIfNecessary(value, optionsArgument) {
        var clone = optionsArgument && optionsArgument.clone === true;
        return (clone && isMergeableObject(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
    }

    function defaultArrayMerge(target, source, optionsArgument) {
        var destination = target.slice();
        source.forEach(function(e, i) {
            if (typeof destination[i] === 'undefined') {
                destination[i] = cloneIfNecessary(e, optionsArgument);
            } else if (isMergeableObject(e)) {
                destination[i] = deepmerge(target[i], e, optionsArgument);
            } else if (target.indexOf(e) === -1) {
                destination.push(cloneIfNecessary(e, optionsArgument));
            }
        });
        return destination
    }

    function mergeObject(target, source, optionsArgument) {
        var destination = {};
        if (isMergeableObject(target)) {
            Object.keys(target).forEach(function(key) {
                destination[key] = cloneIfNecessary(target[key], optionsArgument);
            });
        }
        Object.keys(source).forEach(function(key) {
            if (!isMergeableObject(source[key]) || !target[key]) {
                destination[key] = cloneIfNecessary(source[key], optionsArgument);
            } else {
                destination[key] = deepmerge(target[key], source[key], optionsArgument);
            }
        });
        return destination
    }

    function deepmerge(target, source, optionsArgument) {
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var options = optionsArgument || { arrayMerge: defaultArrayMerge };
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

        if (!sourceAndTargetTypesMatch) {
            return cloneIfNecessary(source, optionsArgument)
        } else if (sourceIsArray) {
            var arrayMerge = options.arrayMerge || defaultArrayMerge;
            return arrayMerge(target, source, optionsArgument)
        } else {
            return mergeObject(target, source, optionsArgument)
        }
    }

    deepmerge.all = function deepmergeAll(array, optionsArgument) {
        if (!Array.isArray(array) || array.length < 2) {
            throw new Error('first argument should be an array with at least two elements')
        }

        // we are sure there are at least 2 values, so it is safe to have no initial value
        return array.reduce(function(prev, next) {
            return deepmerge(prev, next, optionsArgument)
        })
    };

    var deepmerge_1 = deepmerge;

    var area = {
        type: 'serial',
        theme: 'calcite',
        chartCursor: {
            categoryBalloonEnabled: false,
            valueLineBalloonEnabled: true
        },
        graphs: [{
                bullet: 'circle',
                bulletAlpha: 1,
                bulletBorderAlpha: 0.8,
                bulletBorderThickness: 0,
                dashLengthField: 'dashLengthLine',
                fillAlphas: 0.5,
                useLineColorForBulletBorder: true
            }],
        legend: {
            horizontalGap: 10,
            position: 'bottom',
            useGraphSettings: true,
            markerSize: 10
        },
        valueAxes: [{
                stackType: 'regular'
            }],
        export: {
            enabled: true
        }
    };

    var bar = {
        type: 'serial',
        rotate: false,
        theme: 'calcite',
        chartCursor: {
            categoryBalloonEnabled: false
        },
        graphs: [{
                type: 'column',
                newStack: true
            }],
        legend: {
            valueAlign: 'left',
            spacing: 25
        },
        valueAxes: [{
                stackType: 'regular'
            }],
        export: {
            enabled: true
        }
    };

    var barHorizontal = {
        type: 'serial',
        theme: 'calcite',
        rotate: true,
        chartCursor: {
            leaveCursor: true,
            valueLineEnabled: true,
            categoryBalloonEnabled: false
        },
        graphs: [{
                type: 'column',
            }],
        legend: {},
        valueAxes: [{
                gridAlpha: 0.2,
                stackType: 'regular'
            }],
        export: {
            enabled: true
        }
    };

    var line = {
        type: 'serial',
        theme: 'calcite',
        chartCursor: {
            categoryBalloonEnabled: false,
            valueLineBalloonEnabled: true
        },
        graphs: [{
                bullet: 'circle',
                bulletAlpha: 1,
                bulletBorderAlpha: 0.8,
                bulletBorderThickness: 0,
                // bulletColor: '#FFFFFF',
                dashLengthField: 'dashLengthLine',
                fillAlphas: 0,
                useLineColorForBulletBorder: true
            }],
        legend: {
            // horizontalGap: 10,
            position: 'bottom',
            useGraphSettings: true
        },
        export: {
            enabled: true
        }
    };

    var pie = {
        type: 'pie',
        theme: 'calcite',
        innerRadius: '0%',
        startDuration: 0,
        graphs: [{}],
        groupPercent: 5,
        balloon: {
            fixedPosition: true
        },
        legend: {
            enabled: false
        },
        export: {
            enabled: true
        }
    };

    var radar = {
        type: 'radar',
        valueAxes: [{
                gridType: 'circles',
                minimum: 0
            }],
        polarScatter: {
            minimum: 0,
            maximum: 400,
            step: 1
        },
        startDuration: 0,
        graphs: [{ graphFillAlpha: 0 }],
        groupPercent: 5,
        balloon: {
            fixedPosition: true
        },
        legend: {
            position: 'right',
            marginRight: 100,
            autoMargins: false
        },
    };

    var scatter = {
        type: 'xy',
        theme: 'calcite',
        valueAxes: [{
                axisAlpha: 0.8,
                gridAlpha: 0.2,
                position: 'bottom',
            }, {
                axisAlpha: 0.8,
                gridAlpha: 0.2,
                position: 'left'
            }],
        chartScrollbar: {
            scrollbarHeight: 5,
            offset: -1,
            backgroundAlpha: 0.1,
            backgroundColor: '#888888',
            selectedBackgroundColor: '#67b7dc',
            selectedBackgroundAlpha: 1,
            dragIconWidth: 15,
            dragIconHeight: 15,
        },
        chartCursor: {
            categoryBalloonEnabled: true,
            cursorAlpha: 0.3,
            valueLineAlpha: 0.3,
            valueLineBalloonEnabled: true
        },
        graphs: [{
                fillAlphas: 0,
                lineAlpha: 0,
                bullet: 'circle',
                bulletBorderAlpha: 0.2,
                bulletAlpha: 0.8,
                valueField: null,
                xField: null,
                yField: null,
            }],
        export: {
            enabled: true
        }
    };

    var timeline = {
        type: 'serial',
        theme: 'calcite',
        chartCursor: {
            categoryBalloonEnabled: false,
            valueLineBalloonEnabled: true
        },
        graphs: [{
                bullet: 'circle',
                bulletAlpha: 1,
                bulletBorderAlpha: 0.8,
                bulletBorderThickness: 0,
                // bulletColor: '#FFFFFF',
                dashLengthField: 'dashLengthLine',
                fillAlphas: 0,
                useLineColorForBulletBorder: true
            }],
        legend: {
            // horizontalGap: 10,
            position: 'bottom',
            useGraphSettings: true
        },
        categoryAxis: {
            parseDates: true
        },
        export: {
            enabled: true
        }
    };

    var specs = {
        bar: bar,
        'bar-horizontal': barHorizontal,
        line: line,
        area: area,
        pie: pie,
        radar: radar,
        scatter: scatter,
        timeline: timeline
    };

    // TODO: how to have access to IDefinition
    function renderChart(elementId, definition, data) {
        if (definition.type === 'custom') {
            var chart_1 = AmCharts.makeChart(elementId, definition.specification);
            return chart_1;
        }
        // Clone/copy spec and data
        // Longer than normal conditional so setting as its own const
        var hasSpecAndIsntString = definition.specification && typeof definition.specification !== 'string';
        // ternary checking to see if there is a def.spec and that it is NOT a string (url)
        // if true than return def.spec. If not true than fetch a premade spec
        var spec = hasSpecAndIsntString ? clone(definition.specification) : fetchSpec(definition.type);
        var copyData = clone(data);
        // Set the spec's data
        spec.dataProvider = copyData;
        // Apply the series
        if (!!definition.datasets) {
            spec = fillInSpec(spec, definition);
        }
        // Apply overrides
        if (definition.overrides) {
            // NOTE: this counts on using deepmerge < 2.x
            // see: https://github.com/KyleAMathews/deepmerge#arraymerge
            spec = deepmerge_1(spec, definition.overrides, { clone: true });
        }
        var chart = AmCharts.makeChart(elementId, spec);
        // If it is a pie chart
        if (definition.type === 'pie') {
            // Set pie chart balloonText
            chart.balloonText = getPieBalloonText(definition);
        }
        return chart;
    }
    function getPieBalloonText(definition) {
        // Set label based on whether or not there actually is a category label
        var categoryLabel = !!definition.series[0].category.label ? definition.series[0].category.label + ": " : '';
        // Set label based on whether or not there actually is a value label
        var valueLabel = !!definition.series[0].value.label ? definition.series[0].value.label + ": " : '';
        // return balloonText
        return "<div>" + categoryLabel + "[[title]]</div><div>" + valueLabel + "[[percents]]% ([[value]])</div>";
    }
    function fillInSpec(spec, definition) {
        // Grab the graphSpec from the spec
        var graphSpec = spec.graphs.pop();
        var isJoined = definition.datasets.length > 1;
        // category field will be 'categoryField' in the case of joined datasets
        // otherwise get it from the first series
        spec.categoryField = isJoined ? 'categoryField' : definition.series[0].category.field;
        // Set tabIndex for the chart
        spec.tabIndex = 0;
        // Add a legend in case it's not on the spec
        if (!spec.legend) {
            spec.legend = {};
        }
        // TODO This is needed as 'legend.enable' has been renamed 'legend.visible'. We are only introducing
        // breaking changes on major releases.
        // Remove the line below on next breaking change
        /* istanbul ignore next since we're going to remove this */
        if (definition.legend && definition.legend.hasOwnProperty('enable')) {
            definition.legend.visible = definition.legend.enable;
        }
        // adjust legend and axis labels for single series charts
        if (definition.series.length === 1 && (definition.type !== 'pie' && definition.type !== 'radar')) {
            // don't show legend by default for single series charts
            spec.legend.enabled = false;
            // get default axis labels from series
            var categoryAxisTitle_1 = definition.series[0].category.label;
            var valueAxisTitle_1 = definition.series[0].value.label;
            if (spec.type === 'xy' && Array.isArray(spec.valueAxes)) {
                // for xy charts we treat the x axis as the category axis
                // and the y axis as the value axis
                spec.valueAxes.forEach(function (axis) {
                    /* istanbul ignore else since we can only be smart about bottom/left axis labels */
                    if (axis.position === 'bottom') {
                        axis.title = categoryAxisTitle_1;
                    }
                    else if (axis.position === 'left') {
                        axis.title = valueAxisTitle_1;
                    }
                });
            }
            else {
                // line/area specs don't define axes
                if (!spec.valueAxes) {
                    spec.valueAxes = [{}];
                }
                spec.valueAxes[0].title = definition.series[0].value.label;
                spec.valueAxes[0].position = 'left';
                /* istanbul ignore else until we have a test for a timeline definition/spec */
                if (!spec.categoryAxis) {
                    spec.categoryAxis = {};
                }
                spec.categoryAxis.title = categoryAxisTitle_1;
            }
        }
        // Handle Legend in case.
        if (definition.legend) {
            var legend = definition.legend;
            var supportedLegendPositions = ['top', 'bottom', 'left', 'right'];
            if (legend.hasOwnProperty('visible')) {
                spec.legend.enabled = legend.visible;
                // If there is a legend on the page add a tabIndex
                spec.legend.tabIndex = 0;
            }
            if (legend.position && supportedLegendPositions.indexOf(legend.position) > -1) {
                spec.legend.position = legend.position;
            }
        }
        // Handle styles...
        /* istanbul ignore if */
        if (definition.style) {
            // snag out style
            var style = definition.style;
            // handle margins
            /* istanbul ignore if */
            if (style.padding) {
                var padding = style.padding;
                // Assume we need to set auto margins false
                spec.autoMargins = false;
                if (padding.hasOwnProperty('top')) {
                    spec.marginTop = padding.top;
                }
                if (padding.hasOwnProperty('bottom')) {
                    spec.marginBottom = padding.bottom;
                }
                if (padding.hasOwnProperty('left')) {
                    spec.marginLeft = padding.left;
                }
                if (padding.hasOwnProperty('right')) {
                    spec.marginRight = padding.right;
                }
            }
            // If there is a pie property
            /* istanbul ignore if */
            if (style.pie) {
                var pie = style.pie;
                // A range from 0 - n where n is the inner radius of the pie chart. Anything above a 0
                // turns the chart into a donut chart. Can be a number for pixels or a percent.
                if (pie.hasOwnProperty('innerRadius')) {
                    spec.innerRadius = pie.innerRadius;
                }
                // How far a pie chart slice will pull out when selected. Can be a number for pixels or a percent
                if (pie.hasOwnProperty('expand')) {
                    spec.pullOutRadius = pie.expand;
                }
            }
            if (style.colors && Array.isArray(style.colors)) {
                spec.colors = style.colors;
            }
        }
        // Iterate over datasets
        definition.datasets.forEach(function (dataset, d) {
            var datasetName = dataset.name;
            // For each dataset iterate over series
            definition.series.forEach(function (series, s) {
                if (dataset.name === series.source) {
                    var graph = clone(graphSpec);
                    // use the value field label for the graph's title
                    graph.title = series.value.label;
                    // value field will contain dataset name if joined
                    graph.valueField = isJoined ? datasetName + "_" + series.value.field : series.value.field;
                    // TODO: map other fields besides value like color, size, etc
                    // tooltip
                    graph.balloonText = "<div>" + series.category.label + ": [[" + spec.categoryField + "]]</div><div>" + graph.title + ": [[" + graph.valueField + "]]</div>";
                    // Group vs. stack
                    if (!!series.stack && graph.newStack) {
                        graph.newStack = false;
                    }
                    // special props for pie charts
                    if (definition.type === 'pie') {
                        spec.titleField = spec.categoryField;
                        spec.valueField = graph.valueField;
                    }
                    // special props for x/y types (scatter, bubble)
                    if (spec.type === 'xy' && !!series.category && !!series.value) {
                        graph.xField = series.category.field;
                        graph.yField = series.value.field;
                        graph.balloonText = "<div>" + series.category.label + ": [[" + series.category.field + "]]</div><div>" + series.value.label + ": [[" + series.value.field + "]]</div>";
                        // bubble
                        if (spec.type === 'xy' && series.size) {
                            graph.valueField = series.size.field;
                            graph.balloonText = graph.balloonText + "<div>" + series.size.label + ": [[" + graph.valueField + "]]</div>";
                        }
                        else {
                            delete graph.valueField;
                        }
                    }
                    spec.graphs.push(graph);
                }
            });
        });
        return spec;
    }
    function fetchSpec(type) {
        var spec = type;
        if (spec === 'time') {
            console.warn("'time' is no longer a supported type. Please use 'timeline' instead");
            spec = 'timeline';
        }
        else if (spec === 'bubble') {
            console.warn("'bubble' is no longer a supported type. Please use 'scatter' instead");
            spec = 'scatter';
        }
        else if (spec === 'grouped') {
            console.warn("'grouped' is no longer a supported type. Please use 'bar' instead");
            spec = 'bar';
        }
        return clone(specs[spec]);
    }
    function clone(json) {
        return JSON.parse(JSON.stringify(json));
    }
    // TODO: remove
    var render = {
        renderChart: renderChart,
        fillInSpec: fillInSpec,
        fetchSpec: fetchSpec
    };

    function cedarAmCharts(elementId, definition, data) {
        if ((!elementId || !definition || !data) && (definition.type && definition.type !== 'custom')) {
            var err = new Error('Element Id, definition, and data are all required.');
            throw err;
        }
        if (definition.type && definition.type === 'custom') {
            return render.renderChart(elementId, definition);
        }
        return render.renderChart(elementId, definition, data);
    }

    exports.cedarAmCharts = cedarAmCharts;
    exports.default = cedarAmCharts;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=cedar-amcharts.js.map
